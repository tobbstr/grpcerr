package grpcerr

import (
	"google.golang.org/genproto/googleapis/rpc/errdetails"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
)

const (
	defaultInvalidArgumentErrMsg    = "Client specified an invalid argument. Check error details for more information."
	defaultOutOfRangeErrMsg         = "Client specified an invalid range."
	defaultFailedPreconditionErrMsg = "Request can not be executed in the current system state, such as deleting a non-empty directory."
	defaultUnauthenticatedErrMsg    = "Request not authenticated due to missing, invalid, or expired security credentials."
	defaultPermissionDeniedErrMsg   = "Client does not have sufficient permission. This can happen because the client doesn't have permission, or the API has not been enabled."
	defaultAbortedErrMsg            = "Concurrency conflict, such as read-modify-write conflict."
	defaultNotFoundErrMsg           = "A specified resource is not found."
	defaultAlreadyExistsErrMsg      = "Resource a client tried to create already exists."
	defaultResourceExhaustedErrMsg  = "Either out of resource quota or reaching rate limiting. The client should look for google.rpc.QuotaFailure error detail for more information."
	defaultCanceledErrMsg           = "Request cancelled by the client."
	defaultDataLossErrMsg           = "Unrecoverable data loss or data corruption. The client should report the error to the user."
	defaultUnknownErrMsg            = "Unknown server error. Typically a server bug."
	defaultInternalErrMsg           = "Internal server error. Typically a server bug."
	defaultUnimplementedErrMsg      = "API method not implemented by the server."
	defaultNotAvailableErrMsg       = "Network error occurred before reaching the server. Typically a network outage or misconfiguration."
	defaultUnavailableErrMsg        = "Service unavailable. Typically the server is down."
	defaultDeadlineExceededErrMsg   = "Request deadline exceeded. This will happen only if the caller sets a deadline that is shorter than the method's default deadline (i.e. requested deadline is not enough for the server to process the request) and the request did not finish within the deadline."
)

// AddDebugInfo adds additional debug info to a gRPC error. For example useful when the server
// wants to include a stack trace.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func AddDebugInfo(gRPCErr *status.Status, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	return gRPCErr.WithDetails(debugInfo)
}

// AddRequestInfo adds metadata about the request that clients can attach when filing a bug
// or providing other forms of feedback.
//
//	requestID:		An opaque string that should only be interpreted by the service generating
//					it. For example, it can be used to identify requests in the service's logs.
//	servingData:	Any data that was used to serve this request. For example, an encrypted
//					stack trace that can be sent back to the service provider for debugging.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func AddRequestInfo(gRPCErr *status.Status, requestID, servingData string) (*status.Status, error) {
	requestInfoDetails := errdetails.RequestInfo{
		RequestId:   requestID,
		ServingData: servingData,
	}

	return gRPCErr.WithDetails(&requestInfoDetails)
}

// AddHelp adds links to documentation or for performing an out of band action.
//
// For example, if a quota check failed with an error indicating the calling
// project hasn't enabled the accessed service, this can contain a URL pointing
// directly to the right place in the developer console to flip the bit.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func AddHelp(gRPCErr *status.Status, links []*errdetails.Help_Link) (*status.Status, error) {
	if len(links) == 0 {
		return gRPCErr, nil
	}

	helpDetails := errdetails.Help{Links: links}

	return gRPCErr.WithDetails(&helpDetails)
}

// AddLocalizedMessage adds a localized error message.
func AddLocalizedMessage(gRPCErr *status.Status, locale, msg string) (*status.Status, error) {
	localizedMessageDetails := errdetails.LocalizedMessage{
		Locale:  locale,
		Message: msg,
	}

	return gRPCErr.WithDetails(&localizedMessageDetails)
}

// NewInvalidArgument constructs a gRPC error that indicates the client specified an invalid argument.
// Note that this differs from FailedPrecondition. It indicates arguments that are problematic regardless
// of the state of the system (e.g., a malformed file name).
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewInvalidArgument(errMsg string, fieldViolations []*errdetails.BadRequest_FieldViolation) (*status.Status, error) {
	return newGRPCErrorWithBadRequestDetails(codes.InvalidArgument, errMsg, fieldViolations)
}

func newGRPCErrorWithBadRequestDetails(code codes.Code, errMsg string, fieldViolations []*errdetails.BadRequest_FieldViolation) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(code, defaultInvalidArgumentErrMsg)
	} else {
		st = status.New(code, errMsg)
	}

	if len(fieldViolations) == 0 {
		return st, nil
	}

	badRequestDetails := errdetails.BadRequest{FieldViolations: fieldViolations}

	return st.WithDetails(&badRequestDetails)
}

func jsonBytesFromGrpcStatus(status *status.Status) ([]byte, error) {
	data, err := protojson.Marshal(status.Proto())
	if err != nil {
		return nil, err
	}

	return data, nil
}

// NewOutOfRange constructs a gRPC error that means the operation was
// attempted past the valid range.
// E.g., seeking or reading past end of file.
//
// Unlike InvalidArgument, this error indicates a problem that may
// be fixed if the system state changes. For example, a 32-bit file
// system will generate InvalidArgument if asked to read at an
// offset that is not in the range [0,2^32-1], but it will generate
// OutOfRange if asked to read from an offset past the current
// file size.
//
// There is a fair bit of overlap between FailedPrecondition and
// OutOfRange. We recommend using OutOfRange (the more specific
// error) when it applies so that callers who are iterating through
// a space can easily look for an OutOfRange error to detect when
// they are done.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewOutOfRange(errMsg string, fieldViolations []*errdetails.BadRequest_FieldViolation) (*status.Status, error) {
	return newGRPCErrorWithBadRequestDetails(codes.OutOfRange, errMsg, fieldViolations)
}

// NewFailedPrecondition constructs a gRPC error that indicates operation was rejected because the
// system is not in a state required for the operation's execution.
// For example, directory to be deleted may be non-empty, an rmdir
// operation is applied to a non-directory, etc.
//
// A litmus test that may help a service implementor in deciding
// between FailedPrecondition, Aborted, and Unavailable:
//  (a) Use Unavailable if the client can retry just the failing call.
//  (b) Use Aborted if the client should retry at a higher-level
//      (e.g., restarting a read-modify-write sequence).
//  (c) Use FailedPrecondition if the client should not retry until
//      the system state has been explicitly fixed. E.g., if an "rmdir"
//      fails because the directory is non-empty, FailedPrecondition
//      should be returned since the client should not retry unless
//      they have first fixed up the directory by deleting files from it.
//  (d) Use FailedPrecondition if the client performs conditional
//      REST Get/Update/Delete on a resource and the resource on the
//      server does not match the condition. E.g., conflicting
//      read-modify-write on the same resource.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewFailedPrecondition(errMsg string, violations []*errdetails.PreconditionFailure_Violation) (*status.Status, error) {
	return newGRPCErrorWithFailedPreconditionDetails(codes.FailedPrecondition, errMsg, violations)
}

func newGRPCErrorWithFailedPreconditionDetails(code codes.Code, errMsg string, violations []*errdetails.PreconditionFailure_Violation) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(code, defaultFailedPreconditionErrMsg)
	} else {
		st = status.New(code, errMsg)
	}

	if len(violations) == 0 {
		return st, nil
	}

	failedPreconditionsViolationDetails := errdetails.PreconditionFailure{Violations: violations}

	return st.WithDetails(&failedPreconditionsViolationDetails)
}

// NewUnauthenticated constructs a gRPC error that indicates the request does not have valid
// authentication credentials for the operation.
//
// The gRPC framework will generate this error code when the
// authentication metadata is invalid or a Credentials callback fails,
// but also expect authentication middleware to generate it.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewUnauthenticated(errMsg string, errorInfo *errdetails.ErrorInfo) (*status.Status, error) {
	return newGRPCErrorWithErrorInfo(codes.Unauthenticated, errMsg, errorInfo)
}

func newGRPCErrorWithErrorInfo(code codes.Code, errMsg string, errorInfo *errdetails.ErrorInfo) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		switch code {
		case codes.Unauthenticated:
			st = status.New(code, defaultUnauthenticatedErrMsg)
		case codes.PermissionDenied:
			st = status.New(code, defaultPermissionDeniedErrMsg)
		case codes.Aborted:
			st = status.New(code, defaultAbortedErrMsg)
		}
	} else {
		st = status.New(code, errMsg)
	}

	return st.WithDetails(errorInfo)
}

// NewPermissionDenied constructs a gRPC error that indicates the caller does not have permission to
// execute the specified operation. It must not be used for rejections
// caused by exhausting some resource (use ResourceExhausted
// instead for those errors). It must not be
// used if the caller cannot be identified (use Unauthenticated
// instead for those errors).
//
// This error code will not be generated by the gRPC core framework,
// but expect authentication middleware to use it.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewPermissionDenied(errMsg string, errorInfo *errdetails.ErrorInfo) (*status.Status, error) {
	return newGRPCErrorWithErrorInfo(codes.PermissionDenied, errMsg, errorInfo)
}

// NewAborted constructs a gRPC error that indicates the operation was aborted, typically due to a
// concurrency issue like sequencer check failures, transaction aborts,
// etc.
//
// See litmus test above for deciding between FailedPrecondition,
// Aborted, and Unavailable.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewAborted(errMsg string, errorInfo *errdetails.ErrorInfo) (*status.Status, error) {
	return newGRPCErrorWithErrorInfo(codes.Aborted, errMsg, errorInfo)
}

// NewNotFound constructs a gRPC error that means some requested entity (e.g., file or directory) was
// not found.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewNotFound(errMsg string, resourceInfo *errdetails.ResourceInfo) (*status.Status, error) {
	return newGRPCErrorWithResourceInfo(codes.NotFound, errMsg, resourceInfo)
}

// NewAlreadyExists constructs a gRPC error that means an attempt to create an entity failed because one
// already exists.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewAlreadyExists(errMsg string, resourceInfo *errdetails.ResourceInfo) (*status.Status, error) {
	return newGRPCErrorWithResourceInfo(codes.AlreadyExists, errMsg, resourceInfo)
}

func newGRPCErrorWithResourceInfo(code codes.Code, errMsg string, resourceInfo *errdetails.ResourceInfo) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		switch code {
		case codes.NotFound:
			st = status.New(code, defaultNotFoundErrMsg)
		case codes.AlreadyExists:
			st = status.New(code, defaultAlreadyExistsErrMsg)
		}
	} else {
		st = status.New(code, errMsg)
	}

	return st.WithDetails(resourceInfo)
}

// NewResourceExhausted constructs a gRPC error that indicates some resource has been exhausted, perhaps
// a per-user quota, or perhaps the entire file system is out of space.
//
// This error code will be generated by the gRPC framework in
// out-of-memory and server overload situations, or when a message is
// larger than the configured maximum size.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewResourceExhausted(errMsg string, quotaViolations []*errdetails.QuotaFailure_Violation) (*status.Status, error) {
	return newGRPCErrorWithQuotaFailure(codes.ResourceExhausted, errMsg, quotaViolations)
}

func newGRPCErrorWithQuotaFailure(code codes.Code, errMsg string, violations []*errdetails.QuotaFailure_Violation) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(code, defaultResourceExhaustedErrMsg)
	} else {
		st = status.New(code, errMsg)
	}

	quotaFailureDetails := errdetails.QuotaFailure{Violations: violations}

	return st.WithDetails(&quotaFailureDetails)
}

// NewCancelled constructs a gRPC error that indicates the operation was canceled (typically by the caller).
//
// The gRPC framework will generate this error code when cancellation
// is requested.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewCancelled(errMsg string) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(codes.Canceled, defaultCanceledErrMsg)
	} else {
		st = status.New(codes.Canceled, errMsg)
	}

	return st, nil
}

// NewDataLoss constructs a gRPC error that indicates unrecoverable data loss or corruption.
//
// This error code will not be generated by the gRPC framework.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewDataLoss(errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(codes.DataLoss, defaultCanceledErrMsg)
	} else {
		st = status.New(codes.DataLoss, errMsg)
	}

	return st.WithDetails(debugInfo)
}

func newGRPCErrorWithDebugInfo(code codes.Code, errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		switch code {
		case codes.DataLoss:
			st = status.New(code, defaultDataLossErrMsg)
		case codes.Unknown:
			st = status.New(code, defaultUnknownErrMsg)
		case codes.Internal:
			st = status.New(code, defaultInternalErrMsg)
		case codes.Unavailable:
			st = status.New(code, defaultUnavailableErrMsg)
		case codes.DeadlineExceeded:
			st = status.New(code, defaultDeadlineExceededErrMsg)
		}
	} else {
		st = status.New(code, errMsg)
	}

	return st.WithDetails(debugInfo)
}

// NewUnknown constructs a gRPC error that means an unknown error has occured.
// An example of where this error may be returned is
// if a Status value received from another address space belongs to
// an error-space that is not known in this address space. Also
// errors raised by APIs that do not return enough error information
// may be converted to this error.
//
// The gRPC framework will generate this error code in the above two
// mentioned cases.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewUnknown(errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	return newGRPCErrorWithDebugInfo(codes.Unknown, errMsg, debugInfo)
}

// NewInternal construct a gRPC error that means some invariants expected by underlying
// system has been broken. If you see one of these errors,
// something is very broken.
//
// This error code will be generated by the gRPC framework in several
// internal error conditions.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewInternal(errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	return newGRPCErrorWithDebugInfo(codes.Internal, errMsg, debugInfo)
}

// NewUnimplemented constructs a gRPC error that indicates operation is not implemented or not
// supported/enabled in this service.
//
// This error code will be generated by the gRPC framework. Most
// commonly, you will see this error code when a method implementation
// is missing on the server. It can also be generated for unknown
// compression algorithms or a disagreement as to whether an RPC should
// be streaming.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewUnimplemented(errMsg string) (*status.Status, error) {
	var st *status.Status
	if errMsg == "" {
		st = status.New(codes.Unimplemented, defaultUnimplementedErrMsg)
	} else {
		st = status.New(codes.Unimplemented, errMsg)
	}

	return st, nil
}

// NewUnavailable constructs a gRPC error that indicates the service is currently unavailable.
// This is a most likely a transient condition and may be corrected
// by retrying with a backoff. Note that it is not always safe to retry
// non-idempotent operations.
//
// See litmus test above for deciding between FailedPrecondition,
// Aborted, and Unavailable.
//
// This error code will be generated by the gRPC framework during
// abrupt shutdown of a server process or network connection.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewUnavailable(errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	return newGRPCErrorWithDebugInfo(codes.Unavailable, errMsg, debugInfo)
}

// NewDeadlineExceeded constructs a gRPC error that means operation expired before completion.
// For operations that change the state of the system, this error may be
// returned even if the operation has completed successfully. For
// example, a successful response from a server could have been delayed
// long enough for the deadline to expire.
//
// The gRPC framework will generate this error code when the deadline is
// exceeded.
//
// Source: https://github.com/grpc/grpc-go/blob/master/codes/codes.go
func NewDeadlineExceeded(errMsg string, debugInfo *errdetails.DebugInfo) (*status.Status, error) {
	return newGRPCErrorWithDebugInfo(codes.DeadlineExceeded, errMsg, debugInfo)
}
